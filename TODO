Spatial TODO List
=================

(Also used as a detailed roadmap, and changes according to user
expectations, interests or simply progress...)


VERSION 2.0.0

* Mar 11 Finish the implementation of the self-balancing containers,
           and create the new family of containers, frozen_pointset,
           in order to store points without rebalancing. By default,
           *_pointset will be self-blancing containers. This involves
           a heavy unit-testing and thus, it should take a good 3
           months. DONE!

* Jun 11 Some documentation and unit test missing on the first
           release, so we just need to add them. Just a few are
           missing, only. Additionaly, check that the library is
           compiling fine on Visual Studio.
           DONE!

* Jul 11 Add interator_cast() operators to cast a view interator into
           a container iterator, to facilitate erasing a node from a
           container, for example. Cause it currently involves quite a
           messy use of iterator constructor. DONE! (Iterator casting
           is supported in the iterator themselves)

* Dec 11 Implementation of pointmap containers. Need to add quite a
           bit of unit testing, cause they differ from pointset in the
           sense that their iterator are not always constant. It
           should also take about 2 months. DONE!

* Feb 12 Work on boxset containers, add a new type of iterator:
           contain_iterator and intersect_iterator which walk through
           all the boxes that are contained in a range or that are
           intersecting a range, respectively. With unit tests, that
           should take a good 3 months. DONE!

* May 12 Add the boxmap family of iterators. DONE!

* Oct 12 Add a new type of iterator known as ordered_iterator. This
           iterator always walks through the nodes of the tree in the
           same order. This iterator is absolutely necessary to
           properly implement some elementary functions such as "=="
           between containers. DONE!


VERSION 2.1.0

* May 13 Complete General doxygen documention with details on
           container and views, elaboration of how to write geometry,
           etc. This documentation should serve as a complete user
           manual, it should be accompanied by a bit of library
           polishing. Should take about 2 months. It would mark the
           milestone 2.0 release, and the end of the beta period, if
           enough people have used it. In progress...

* Jul 13 Equal_iterator should stand on its own with its own
           optimizations for the static invarient in the kdree. DONE!

* Nov 13 Final optimization: work on adding performance-based tests
           and comparison with other libraries in the market. Wouldn't
           it be nice to see how it fares against ANN or libkdtree++?

* Jan 14 Implementing containers that hold only unique keys, with
           bracket operators just like std::map and std::set. They
           would be simply point_set, box_set, point_map and box_map.

* Mar 14 Add a range erase function that operates on 2 basic tree
           iterators. This is complicated to write because of the
           invarient.


VERSION 2.2.0

* Jul 14 Addition of algorithms. A few come to mind: approximative
           nearest neighbor search, min/max depth, etc.

* Sep 14 Addition of intrusive containers or flat container for every
           existing ones (haven't decided wether intrusive or flat is
           better) I suppose that since you are probably using the
           tree for it's algorthims, flat container may present a good
           alterative, while intrusive container may be slower in
           practice, the value are located out of the tree in
           memory. The containers should have a rather limited inpact
           on the existing code if possible, but should make a great
           difference in terms of performance for those who need
           them. Should take about 2 months.

* Dec 14 Implementation of a new near cache oblivious allocator solely
           dedicated to be used with the spatial library. This cache
           oblivious allocator is used to speed up the frequent
           walking operation within the tree. How does it work? First,
           it does not use locking, and creates new allocation per
           container. That means it is thread-local by design and
           fast. Secondly, it uses extensive knownledge of how the
           library uses it's node and so, it is only suitable for use
           with the library itself, and can't be used anywhere else!
           This allocator create storage for a specific number of node
           in power of 2, minus 1. Within the same memory region, or
           block it will represent a sub-tree. The root of the subtree
           is always the first node. One of the child node sits next
           the root, while the other child node sits in the middle of
           the remaining space, recursively. Due to this recursion,
           regardless of block size, cache size or other parameters,
           there is always an entire subtree that will fit in the
           cache. To locate the nodes within the block, the hint
           pointer is used. The hint pointer given is always the
           parent of the node to be allocated. It uses the information
           of available buckets in the block and of the pointer in the
           parent node to find the suitable new bucket position. This
           allocator is also memory efficient: if the node dealloacted
           was the root node of the sub-tree in the block, and was a
           leaf node, the block can safely be deallocated as well.
           Therefore this allocator is fast and needs no extra info on
           top of the information in the tree itself. This allocator
           is therefore optimal for the library, and should speed up
           tree walking a lot... if we never re-balanced containers.
           However we do re-balance containers in this library, hence
           this allocator will be specific to idle_* containers which
           do not reblance. Another allocator, probably not cache
           oblivious, but at least cache-aware (with a user-defined
           bucket size will need to be written)

VERSION 2.3.0

* Mar 15 Add new iterators such at ray_iterator, which travels along a
           vector, in a given space. This iterator works only on
           boxset family of iterators? Some new functions for metric
           should appear and therefore, it would make defining a
           geometry quite a complex business, needing more
           documentation.

* Aug 15 Porting Spatial to scripting/duck-typing languages or
           frameworks? Python, Java, Lua, Ruby, .Net, others? Create a
           new project based on spatial in this case, using the
           version number in the spatial.hpp header.


VERSION 3.0.0

* ??? ?? Version 3.0.0 marks the new major release, breaking backward
           compatibility. What would the future hold for the spatial
           library? Vantage-Point tree support for faster nearest and
           furthest neighbor search?
