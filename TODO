Spatial TODO List
=================

(Also used as a detailed roadmap, and changes according to user
expectations, interests or simply progress...)


VERSION 2.0.0

* Mar 11 Finish the implementation of the self-balancing containers,
           and create the new family of containers, frozen_pointset,
           in order to store points without rebalancing. By default,
           *_pointset will be self-blancing containers. This involves
           a heavy unit-testing and thus, it should take a good 3
           months. DONE!

* Jun 11 Some documentation and unit test missing on the first
           release, so we just need to add them. Just a few are
           missing, only. Additionaly, check that the library is
           compiling fine on Visual Studio.
           DONE!

* Jul 11 Add interator_cast() operators to cast a view interator into
           a container iterator, to facilitate erasing a node from a
           container, for example. Cause it currently involves quite a
           messy use of iterator constructor. DONE! (Iterator casting
           is supported in the iterator themselves)

* Dec 11 Implementation of pointmap containers. Need to add quite a
           bit of unit testing, cause they differ from pointset in the
           sense that their iterator are not always constant. It
           should also take about 2 months. DONE!

* Feb 12 Work on boxset containers, add a new type of iterator:
           contain_iterator and intersect_iterator which walk through
           all the boxes that are contained in a range or that are
           intersecting a range, respectively. With unit tests, that
           should take a good 3 months. DONE!

* May 12 Add the boxmap family of iterators. DONE!

* Oct 12 Add a new type of iterator known as ordered_iterator. This
           iterator always walks through the nodes of the tree in the
           same order. This iterator is absolutely necessary to
           properly implement some elementary functions such as "=="
           between containers. DONE!

* Dec 12 Complete General doxygen documention with details on
           container and views, elaboration of how to write geometry,
           etc. This documentation should serve as a complete user
           manual, it should be accompanied by a bit of library
           polishing. Should take about 2 months. It would mark the
           milestone 2.0 release, and the end of the beta period, if
           enough people have used it. In progress...


VERSION 2.1.0

* Jan 13 Final optimization: work on adding performance-based tests
           and comparison with other libraries in the market. Wouldn't
           it be nice to see how it fares against ANN or libkdtree++?

* Feb 13 Implementing containers that hold only unique keys, with
           bracket operators just like std::map and std::set. They
           would be simply pointset, boxset, pointmap and boxmap.

* Apr 13 Add a range erase function that operates on 2 basic tree
           iterators. This is complicated to write because of the
           invarient.


VERSION 2.2.0

* Jun 13 Addition of intrusive containers for every existing ones. The
           intrusive containers should have a rather limited inpact on
           the existing code if possible, but should make a great
           difference in terms of performance for those who need
           them. Should take about 2 months. In progress...

* Sep 13 Implementation of a new near cache oblivious allocator solely
           dedicated to be used with the spatial library. This cache
           oblivious allocator is used to speed up the frequent
           walking operation within the tree. How does it work? First,
           it does not use locking, and creates new allocation per
           container. That means it is thread-local by design and
           fast. Secondly, it uses extensive knownledge of how the
           library uses it's node and so, it is only suitable for use
           with the library itself, and can't be used anywhere else!
           This allocator create storage for a specific number of node
           in power of 2, minus 1. Within the same memory region, or
           block it will represent a sub-tree. The root of the subtree
           is always the first node. One of the child node sits next
           the root, while the other child node sits in the middle of
           the remaining space, recursively. Due to this recursion,
           regardless of block size, cache size or other parameters,
           there is always an entire subtree that will fit in the
           cache. To locate the nodes within the block, the hint
           pointer is used. The hint pointer given is always the
           parent of the node to be allocated. It uses the information
           of available buckets in the block and of the pointer in the
           parent node to find the suitable new bucket position. This
           allocator is also memory efficient: if the node dealloacted
           was the root node of the sub-tree in the block, and was a
           leaf node, the block can safely be deallocated as well.
           Therefore this allocator is fast and needs no extra info on
           top of the information in the tree itself. This allocator
           is therefore optimal for the library, and should speed up
           tree walking a lot... if we never re-balanced containers.
           However we do re-balance containers in this library, hence
	   this allocator will be specific to idle_* containers which
	   do not reblance. Another allocator, probably not cache 
	   oblivious, but at least cache-aware (with a user-defined
	   bucket size will need to be written)

VERSION 2.3.0

* Nov 13 Add new iterators such at ray_iterator, which travels along a
           vector, in a given geometry. This iterator works only on
           boxset family of iterators. Some new functions for geometry
           should appear and therefore, it would make defining a
           geometry quite a complex business, needing more
           documentation. Should take about 2 months.

* Dec 13 Porting Spatial to scripting/duck-typing languages or
           frameworks? Python, Java, Lua, Ruby, .Net, others? Create a
           new project based on spatial in this case, using the
           version number in the spatial.hpp header.


VERSION 3.0.0

* ??? ?? Version 3.0.0 marks the new major release, breaking backward
           compatibility. What would the future hold for the spatial
           library? Vantage-Point tree support for faster nearest and
	   furthest neighbor search?
